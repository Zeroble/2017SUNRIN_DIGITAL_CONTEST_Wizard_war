<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.js"></script>
    <title>MCMT</title>
</head>

<body>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <script>
        var socket = io.connect('/');
        let copyedUserObjects
        window.onload = function () {
            socket.emit("onload", {
                socketid: socket.id,
                x: player.tempX,
                y: player.tempY,
                color: player.color,
            })
        }
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const SPEED = 3
        class gameObject {
            constructor(width, height) {
                this.x = 0
                this.y = 0
                this.width = width
                this.height = height
            }
        }
        class Player extends gameObject {
            constructor() {
                super(50, 50)
                this.x = canvas.width / 2 - this.height / 2
                this.y = canvas.height / 2 - this.width / 2
                this.tempX = this.x
                this.tempY = this.y
                this.color = "#" + Math.floor(Math.random() * 9) + Math.floor(Math.random() * 9) + Math.floor(Math.random() * 9) + Math.floor(Math.random() * 9) + Math.floor(Math.random() * 9) + Math.floor(Math.random() * 9)
            }
        }
        class mouseClickedPoint {
            constructor() {
                this.x = player.tempX
                this.y = player.tempY
            }
        }
        class points {
            constructor() {
                this.atan2
                this.sin
                this.cos
                this.subx
                this.suby
            }
        }
        player = new Player()
        mouseClickedPoint = new mouseClickedPoint()
        points = new points()
        window.requestAnimationFrame(run);

        function stopMoving() {
            mouseClickedPoint.x = player.tempX
            mouseClickedPoint.y = player.tempY
        }
        function run() {
            context.fillStyle = 'black';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.fillStyle = player.color
            context.fillRect(player.x, player.y, player.width, player.height)

            points.subx = mouseClickedPoint.x - player.tempX
            points.suby = mouseClickedPoint.y - player.tempY
            points.atan2 = Math.atan2(points.subx, points.suby)
            points.sin = Math.sin(points.atan2)
            points.cos = Math.cos(points.atan2)

            for (let i in copyedUserObjects) {
                if (i == socket.id) {
                    player.x = copyedUserObjects[i].x
                    player.y = copyedUserObjects[i].y
                }
                else {
                    context.fillStyle = copyedUserObjects[i].color
                    context.fillRect(copyedUserObjects[i].x, copyedUserObjects[i].y, copyedUserObjects[i].width, copyedUserObjects[i].height)
                    // console.log(copyedUserObjects[i])
                }
            }
            if (points.subx > 0 ? player.tempX + points.sin * SPEED > mouseClickedPoint.x : player.tempX + points.sin * SPEED < mouseClickedPoint.x || points.suby >= 0 ? player.tempY + points.cos * SPEED > mouseClickedPoint.y : player.tempY + points.cos * SPEED < mouseClickedPoint.y) {
                //근처에 도달하면 정지
                player.tempX = mouseClickedPoint.x
                player.tempY = mouseClickedPoint.y
            }

            //     1
            //    ---
            // 2 ㅣ  ㅣ 3 
            //    ---
            //     4
            else if (player.tempX < 0) {
                player.tempX = 0
                stopMoving()
            }
            else if (player.tempX + player.width > canvas.width) {
                player.tempX = canvas.width - player.width
                stopMoving()
            }
            else if (player.tempY < 0) {
                player.tempY = 0
                stopMoving()
            }
            else if (player.tempY + player.height > canvas.height) {
                player.tempY = canvas.height - player.height
                stopMoving()
            }
            else {
                player.tempX += points.sin * SPEED
                player.tempY += points.cos * SPEED
                // console.log("moving")
            }
            if (player.tempX != mouseClickedPoint.x && player.tempY != mouseClickedPoint.y) {
                socket.emit("update", {
                    x: player.tempX,
                    y: player.tempY
                })
            }
            // console.log("emit")
            window.requestAnimationFrame(run);

        }
        socket.on('update', (userObjects) => {
            try {
                copyedUserObjects = JSON.parse(JSON.stringify(userObjects));

            } catch (error) {
                console.log(error)
            }
        })

        document.oncontextmenu = function () { return false; } //메뉴 뜨는거 방지

        function getMousePosition(event) {//마우스 정확한 위치구하는 함수
            const rect = canvas.getBoundingClientRect()
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            }
        }
        window.addEventListener('mousedown', function (event) {
            if (event.button == 2) {//마우스 오른쪽 클릭시
                let pos = getMousePosition(event);
                mouseClickedPoint.x = pos.x - (player.width / 2)
                mouseClickedPoint.y = pos.y - (player.height / 2)
            }
        })
    </script>
</body>

</html>